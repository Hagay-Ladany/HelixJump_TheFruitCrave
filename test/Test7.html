<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Helix Jump: Final Debug</title>
    <style>
        body {
            margin: 0; overflow: hidden; background-color: #222;
            background-position: center; background-size: cover; background-repeat: no-repeat;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none; -webkit-user-select: none;
            transition: background-image 0.5s ease-in-out;
        }
        #canvas-container { width: 100%; height: 100dvh; display: block; }
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
        }
        
        /* HUD */
        #top-bar { display: flex; justify-content: space-between; padding: 20px; width: 100%; box-sizing: border-box; pointer-events: none; }
        #level-info { text-align: left; }
        #level-indicator { font-size: 1.8rem; font-weight: 900; color: white; text-shadow: 2px 2px 0 #000; margin: 0; }
        #timer-display { font-size: 1.5rem; color: #00ffff; font-family: monospace; font-weight: bold; text-shadow: 1px 1px 0 rgba(0,0,0,0.5); }
        #hearts { font-size: 1.2rem; margin-top: 5px; letter-spacing: 1px; }
        #buffs-display { font-size: 1rem; font-weight: bold; margin-top: 5px; text-shadow: 1px 1px 0 #000; min-height: 1.2em; }
        .buff-fast { color: #ffff00; } .buff-slow { color: #76ff03; font-style: italic; } .buff-drill { color: #00ffff; text-shadow: 0 0 5px cyan; }
        
        #item-counters { background: rgba(0,0,0,0.6); padding: 10px 20px; border-radius: 20px; backdrop-filter: blur(4px); display: flex; gap: 15px; height: fit-content; border: 1px solid rgba(255,255,255,0.2); }
        .counter-item { font-size: 1.2rem; color: white; font-weight: bold; }
        #score-board { position: absolute; top: 120px; width: 100%; text-align: center; font-size: 5rem; font-weight: 900; color: rgba(255,255,255,0.2); pointer-events: none; }

        /* Audio Controls */
        .audio-controls { position: absolute; bottom: 20px; left: 20px; display: flex; gap: 15px; z-index: 30; pointer-events: auto; }
        .audio-icon { font-size: 32px; cursor: pointer; background: none; border: none; opacity: 0.8; color: white; text-shadow: 0 2px 4px black; transition: transform 0.1s; }
        .audio-icon:active { transform: scale(0.9); }
        .audio-off { opacity: 0.4; }

        /* Overlays */
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 20; pointer-events: auto; transition: opacity 0.3s; }
        #start-screen { background-color: #2c3e50; background-image: url('images/start_screen.jpg'); background-position: center; background-size: cover; }
        .hidden { opacity: 0; pointer-events: none; }
        h1 { color: white; font-size: 3rem; margin: 0 0 20px 0; text-transform: uppercase; text-shadow: none; font-weight: 900; letter-spacing: 2px; }
        .big-emoji { font-size: 6rem; margin: 10px 0; }
        
        /* Animations */
        @keyframes popIn { 0% { transform: scale(0); opacity: 0; } 80% { transform: scale(1.1); opacity: 1; } 100% { transform: scale(1); } }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.2) rotate(5deg); } 100% { transform: scale(1); } }
        .animate-pop { animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; opacity: 0; }
        .animate-pulse { animation: pulse 1s infinite; }

        .stat-box { background: rgba(255,255,255,0.15); padding: 20px; border-radius: 10px; width: 300px; margin: 20px; text-align: center; color: white; border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(5px); box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .stat-row { display: flex; align-items: center; justify-content: space-between; margin: 8px 0; font-size: 1rem; border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 5px; }
        .stat-label { width: 70px; text-align: left; font-size: 0.9rem; opacity: 0.8; }
        .stat-val { width: 50px; text-align: right; font-weight: bold; }
        .bar-track { flex-grow: 1; height: 6px; background: rgba(0,0,0,0.5); margin: 0 10px; border-radius: 4px; overflow: hidden; }
        .bar-fill { height: 100%; width: 0%; transition: width 1s ease-out; }

        button.btn { background: #ff4757; color: white; border: none; padding: 15px 50px; font-size: 1.5rem; border-radius: 50px; font-weight: bold; cursor: pointer; box-shadow: 0 5px 15px rgba(255, 71, 87, 0.4); transition: transform 0.1s; margin: 10px; text-shadow: 0 1px 2px rgba(0,0,0,0.3); }
        button.btn:active { transform: scale(0.95); }
        button.btn-start { background: #2ed573; box-shadow: 0 5px 15px rgba(46, 213, 115, 0.4); }
        
        .tutorial { position: absolute; bottom: 30px; right: 30px; text-align: right; color: rgba(255,255,255,0.3); font-size: 1rem; font-weight: bold; pointer-events: none; }
    </style>
    
    <script src="js/three.min.js"></script>
    
    <script>
        var Module = {
            onRuntimeInitialized: function() {
                console.log("Audio Engine Ready.");
                window.libopenmpt = Module; 
            }
        };
    </script>
    <script src="chiptune2/libopenmpt.js"></script>
    <script src="chiptune2/chiptune2.js"></script>
</head>
<body>

<div id="canvas-container"></div>
<div id="ui-layer">
    <div id="top-bar">
        <div id="level-info">
            <h2 id="level-indicator">LEVEL 1</h2>
            <div id="timer-display">00:00</div>
            <div id="hearts">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
            <div id="buffs-display"></div>
        </div>
        <div id="item-counters">
            <div class="counter-item">üçé <span id="c-apple">0</span></div>
            <div class="counter-item">üçå <span id="c-banana">0</span></div>
            <div class="counter-item">üç´ <span id="c-choco">0</span></div>
        </div>
    </div>
    <div id="score-board">0</div>
    
    <div class="audio-controls">
        <button id="music-btn" class="audio-icon">üéµ</button>
        <button id="audio-btn" class="audio-icon">üîä</button>
    </div>
    
    <div class="tutorial">DRAG TO ROTATE</div>
</div>

<div id="start-screen" class="overlay">
    <h1>HELIX JUMP</h1>
    <div class="stat-box">
        <p>üçé Life | üçå Speed</p>
        <p>üç´ +5s Time | üíé Drill</p>
        <p style="color:#ff4500; font-weight:bold;">Level 6: THE END</p>
    </div>
    <button class="btn btn-start" id="btn-start">TAP TO START</button>
</div>

<div id="game-over-screen" class="overlay hidden">
    <h1>GAME OVER</h1>
    <div class="big-emoji animate-pulse">üò≠</div>
    <div class="stat-box">
        <p id="fail-reason" style="color:#ff4444; font-weight:bold;">SMASHED!</p>
        <div class="stat-row animate-pop" style="animation-delay: 0.1s;"><span class="stat-label">Score:</span><span class="stat-val" id="go-score">0</span></div>
        <div class="stat-row animate-pop" style="animation-delay: 0.2s;"><span class="stat-label">Best:</span><span class="stat-val" id="go-best">0</span></div>
    </div>
    <button class="btn" id="btn-retry">TRY AGAIN</button>
</div>

<div id="level-complete-screen" class="overlay hidden">
    <h1 id="complete-title">LEVEL COMPLETE!</h1>
    <div class="big-emoji animate-pulse" id="win-emoji">üéâ</div>
    <div class="stat-box">
        <div class="stat-row animate-pop" style="animation-delay: 0.1s;"><span class="stat-label">Time:</span><div class="bar-track"><div class="bar-fill" id="bar-time" style="background:#00ffff"></div></div><span class="stat-val" id="win-time">00:00</span></div>
        <div class="stat-row animate-pop" style="animation-delay: 0.2s;"><span class="stat-label">Fruits:</span><div class="bar-track"><div class="bar-fill" id="bar-fruit" style="background:#2ed573"></div></div><span class="stat-val" id="win-fruit">0/0</span></div>
        <div class="stat-row animate-pop" style="animation-delay: 0.3s;"><span class="stat-label">Rating:</span><div class="bar-track"><div class="bar-fill" id="bar-rating" style="background:#ff4757"></div></div><span class="stat-val" id="win-rating">Good</span></div>
    </div>
    <button class="btn btn-start" id="btn-next">NEXT LEVEL</button>
</div>

<script>
/**
 * HELIX JUMP - FIXED BUILD
 * 1. Sound: Reverted SoundManager to previous working version (V15).
 * 2. Drill: Fixed infinite duration bug.
 * 3. Lava: Level 4 Pole glows red.
 * 4. Monsters: Flipped 90 degrees to face forward (not up).
 */

// --- SAFETY UTILS ---
function updateText(id, text) { const el = document.getElementById(id); if (el) el.innerText = text; }
function updateHTML(id, html) { const el = document.getElementById(id); if (el) el.innerHTML = html; }
function updateBar(id, percent) { const el = document.getElementById(id); if(el) el.style.width = Math.min(100, Math.max(0, percent)) + "%"; }

// --- 1. SOUND MANAGER (REVERTED TO WORKING VERSION) ---
class SoundManager {
    constructor() {
        this.player = null; 
        this.trackMap = { 
            'start_screen': { file: 'start_screen_raina_-_smile', ext: 'xm' },
            'game_over': { file: 'game_over_old_keys', ext: 'mod' },
            'level_1': { file: 'level_1_civilian', ext: 'xm' },
            'level_2': { file: 'level_2_im_a_chip_melody', ext: 'xm' },
            'level_3': { file: 'level_3_arcane_toaster_-_warios_game_room', ext: 'xm' },
            'level_4': { file: 'level_4_god_no_love_me', ext: 'mod' },
            'level_5': { file: 'level_5_jazzberr', ext: 'mod' },
            'level_6': { file: 'level_5_jazzberr', ext: 'mod' }, 
            'you_win': { file: 'you_win_cerror_-_ode_to_maktone', ext: 'mod' }
        };
        this.isMuted = false;
        this.isMusicMuted = false;
        this.currentTrack = "";
        this.lastTrack = ""; 
        
        const AC = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AC();
        this.masterGain = this.ctx.createGain();
        this.masterGain.connect(this.ctx.destination);
        this.masterGain.gain.value = 0.9; 
    }

    init() {
        if (typeof ChiptuneJsPlayer === 'undefined') {
            console.warn("ChiptuneJsPlayer not loaded.");
            return;
        }
        try {
            // EXACT CONFIG FROM V15
            var config = new ChiptuneJsConfig(0); 
            this.player = new ChiptuneJsPlayer(config);
            document.addEventListener('click', () => {
                if(this.player.context && this.player.context.state === 'suspended') {
                    this.player.context.resume();
                }
                if(this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            }, { once:true });
        } catch(e) {
            console.error("Audio Init Failed:", e);
        }
    }

    playTrack(baseName) {
        if(!this.player || this.isMusicMuted) return;
        if(this.currentTrack === baseName) return; 
        
        const trackInfo = this.trackMap[baseName];
        if(!trackInfo) {
            console.warn(`Track not found: ${baseName}`);
            return;
        }
        const url = `sound/${trackInfo.file}.${trackInfo.ext}`;
        this.currentTrack = baseName;
        this.lastTrack = baseName; 
        
        this.player.load(url, (buffer) => {
            this.player.play(buffer);
        });
    }
    
    stopMusic() {
        if(this.player) {
            if(this.currentTrack) {
                this.lastTrack = this.currentTrack;
            }
            this.player.stop();
            this.currentTrack = "";
        }
    }

    toggleMute() { 
        this.isMuted = !this.isMuted;
        if(this.player && this.player.context) {
             if(this.isMuted) this.player.context.suspend();
             else this.player.context.resume();
        }
        if(this.masterGain) this.masterGain.gain.setTargetAtTime(this.isMuted ? 0 : 0.9, this.ctx.currentTime, 0.1);
        
        document.getElementById('audio-btn').classList.toggle('audio-off', this.isMuted);
    }
    
    toggleMusic() {
        this.isMusicMuted = !this.isMusicMuted;
        if(this.isMusicMuted) {
            this.stopMusic();
        } else {
            const trackToResume = this.lastTrack || 'start_screen';
            this.currentTrack = ""; 
            this.playTrack(trackToResume);
        }
        document.getElementById('music-btn').classList.toggle('audio-off', this.isMusicMuted);
    }
    
    playSFX(type) {
        if (!this.ctx || this.isMuted) return;
        switch(type) {
            case 'bounce': this.playTone('triangle', 250, 0.1, 0.2); break;
            case 'collect': this.playTone('sine', 1500, 0.1, 0.4); break;
            case 'damage': this.playTone('sawtooth', 100, 0.3, 0.4); break;
            case 'buff': this.playTone('square', 600, 0.2, 0.3); break; 
            case 'win': this.playWin(); break;
        }
    }

    playTone(type, freq, dur, vol=0.5) {
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        osc.type = type; osc.frequency.setValueAtTime(freq, t);
        osc.connect(g); g.connect(this.masterGain);
        g.gain.setValueAtTime(vol, t); g.gain.exponentialRampToValueAtTime(0.01, t+dur);
        osc.start(t);
        osc.stop(t+dur);
    }

    playWin() {
        const t = this.ctx.currentTime;
        [523.25, 659.25, 783.99, 1046.50].forEach((f,i) => setTimeout(() => this.playTone('triangle', f, 0.3, 0.3), i*100));
    }
}

// --- 2. ASSET FACTORY ---
const AssetFactory = {
    textures: {},
    init() {
        try {
            this.textures['apple'] = this.createEmojiTexture('üçé');
            this.textures['banana'] = this.createEmojiTexture('üçå');
            this.textures['choco'] = this.createEmojiTexture('üç´');
            this.textures['rotten'] = this.createEmojiTexture('ü§¢'); 
            this.textures['diamond'] = this.createEmojiTexture('üíé');
            this.texFloor = this.createFloorTexture();
            this.texStone = this.createStoneTexture();
            this.texPole = this.createPoleTexture();
        } catch(e) {}
    },
    createEmojiTexture(emoji) {
        try {
            const c = document.createElement('canvas'); c.width = 128; c.height = 128;
            const ctx = c.getContext('2d'); ctx.font = '100px serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(emoji, 64, 64); return new THREE.CanvasTexture(c);
        } catch(e) { return null; }
    },
    createFloorTexture: () => {
        const c = document.createElement('canvas'); c.width=256; c.height=256; const ctx = c.getContext('2d');
        ctx.fillStyle = '#fff'; ctx.fillRect(0,0,256,256); ctx.fillStyle = '#ddd';
        for(let i=0;i<8;i++) for(let j=0;j<8;j++) if((i+j)%2) ctx.fillRect(i*32,j*32,32,32);
        ctx.strokeStyle = '#aaa'; ctx.lineWidth = 2; ctx.strokeRect(0,0,256,256);
        const t = new THREE.CanvasTexture(c); t.wrapS = t.wrapT = THREE.RepeatWrapping; t.repeat.set(2,2); return t;
    },
    createStoneTexture: () => {
        const c = document.createElement('canvas'); c.width=256; c.height=256; const ctx = c.getContext('2d');
        ctx.fillStyle = '#444'; ctx.fillRect(0,0,256,256);
        for(let i=0;i<500;i++){ ctx.fillStyle = Math.random()>0.5 ? '#555':'#333'; ctx.fillRect(Math.random()*256, Math.random()*256, 8, 8); }
        ctx.strokeStyle = '#333'; ctx.lineWidth = 1;
        for(let i=0;i<=8;i++) { ctx.beginPath(); ctx.moveTo(i*32,0); ctx.lineTo(i*32,256); ctx.stroke(); }
        for(let i=0;i<=8;i++) { ctx.beginPath(); ctx.moveTo(0,i*32); ctx.lineTo(256,i*32); ctx.stroke(); }
        const t = new THREE.CanvasTexture(c); t.wrapS = t.wrapT = THREE.RepeatWrapping; t.repeat.set(4,4); return t;
    },
    createPoleTexture: () => {
        const c = document.createElement('canvas'); c.width=64; c.height=64; const ctx = c.getContext('2d');
        ctx.fillStyle = '#E8DCC5'; ctx.fillRect(0,0,64,64); ctx.fillStyle = '#D4C3A3';
        for(let i=0;i<50;i++) ctx.fillRect(Math.random()*64, Math.random()*64, 2, 2);
        ctx.strokeStyle = '#C4B39A'; ctx.lineWidth = 1;
        for(let i=0;i<4;i++) { ctx.beginPath(); ctx.moveTo(i*16,0); ctx.lineTo(i*16,64); ctx.stroke(); }
        const t = new THREE.CanvasTexture(c); t.wrapS = t.wrapT = THREE.RepeatWrapping; t.repeat.set(2,20); return t;
    }
};

// --- 3. PARTICLE SYSTEM ---
class ParticleSystem {
    constructor(scene) {
        this.scene = scene; this.pool = [];
        const geo = new THREE.PlaneGeometry(0.2, 0.2);
        const mat = new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.8, side:THREE.DoubleSide});
        for(let i=0; i<30; i++) { const m = new THREE.Mesh(geo, mat.clone()); m.visible = false; this.scene.add(m); this.pool.push(m); }
    }
    spawn(pos, color) {
        for(let i=0; i<5; i++) {
            const m = this.pool.find(p => !p.visible); if(!m) return;
            m.visible = true; m.position.copy(pos); m.position.y += 0.1;
            m.material.color.setHex(color); m.material.opacity = 1.0; m.scale.setScalar(1);
            const ang = Math.random() * 6.28; const spd = 0.05 + Math.random() * 0.05;
            m.userData = { vx: Math.cos(ang)*spd, vy: 0.1+Math.random()*0.1, vz: Math.sin(ang)*spd, life: 1.0 };
        }
    }
    update() {
        for(let m of this.pool) {
            if(!m.visible) continue;
            const d = m.userData; m.position.x += d.vx; m.position.y += d.vy; m.position.z += d.vz;
            d.vy -= 0.01; d.life -= 0.03; m.scale.setScalar(d.life);
            if(d.life <= 0) m.visible = false; m.lookAt(this.scene.position); m.rotation.z += 0.1;
        }
    }
}

// --- 4. GAME CONTROLLER ---
class Game {
    constructor() {
        this.audio = new SoundManager();
        this.level = 1; this.lives = 3; this.score = 0; this.bestScore = 0; this.isPlaying = false;
        this.baseGravity = 0.012; this.jumpForce = 0.20; this.gravity = this.baseGravity; this.velocity = 0;
        this.currentScale = new THREE.Vector3(1,1,1); this.targetScale = new THREE.Vector3(1,1,1);
        this.fastTimer = 0; this.slowTimer = 0; this.invincible = 0; this.drillFloors = 0;
        this.collected = { apple: 0, banana: 0, diamond: 0, choco: 0, rotten: 0 }; 
        this.totalItems = 0; this.levelCollected = 0; this.previousLevelsScore = 0; this.currentLevelMaxDepth = 0;
        
        if (typeof THREE !== 'undefined') this.raycaster = new THREE.Raycaster();
        this.floors = []; this.interactables = []; this.physicsMeshes = []; 
        this.timeLeft = 60; this.maxTime = 60; this.lastTime = 0;
        
        document.getElementById('btn-retry').onclick = () => this.restart(true);
        document.getElementById('btn-next').onclick = () => { if(this.level >= 6) this.restart(true); else { this.level++; this.restart(false); } };
        document.getElementById('audio-btn').onclick = () => this.audio.toggleMute();
        document.getElementById('music-btn').onclick = () => this.audio.toggleMusic();
    }

    start() {
        try {
            document.getElementById('start-screen').style.display = 'none';
            AssetFactory.init();
            this.audio.init();
            this.audio.playTrack('start_screen');
            this.initThreeJS();
        } catch (e) { console.error(e); }
    }

    initThreeJS() {
        this.scene = new THREE.Scene(); this.scene.fog = new THREE.FogExp2(0x111, 0.03);
        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
        this.camera.position.set(0, 8, 15); this.camera.lookAt(0, 0, 0);
        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = false;
        document.getElementById('canvas-container').appendChild(this.renderer.domElement);
        this.scene.add(new THREE.AmbientLight(0xffffff, 1.0));
        this.particles = new ParticleSystem(this.scene);
        this.createCharacter(); this.setupLevel();
        
        let dragging = false, lastX = 0;
        const getX = e => e.clientX || (e.touches && e.touches[0].clientX);
        window.addEventListener('mousedown', e => { dragging=true; lastX=getX(e); });
        window.addEventListener('touchstart', e => { dragging=true; lastX=getX(e); });
        window.addEventListener('mouseup', () => dragging=false);
        window.addEventListener('touchend', () => dragging=false);
        const onMove = (e) => { if(dragging && this.isPlaying && this.tower) { const x = getX(e); this.tower.rotation.y += (x - lastX) * 0.008; lastX = x; } }
        window.addEventListener('mousemove', onMove); window.addEventListener('touchmove', onMove);
        window.addEventListener('resize', () => { this.camera.aspect = window.innerWidth/window.innerHeight; this.camera.updateProjectionMatrix(); this.renderer.setSize(window.innerWidth, window.innerHeight); });
        this.isPlaying = true; this.lastTime = Date.now(); this.loop();
    }
    
    createCharacter() {
        this.ballWrap = new THREE.Group(); this.ballWrap.position.set(0, 2, 2);
        const geo = new THREE.SphereGeometry(0.4, 32, 32);
        this.ballMat = new THREE.MeshBasicMaterial({ color: 0xFF9966 });
        this.ballBody = new THREE.Mesh(geo, this.ballMat); this.ballWrap.add(this.ballBody);
        const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.15, 8), new THREE.MeshBasicMaterial({color:0x5D4037})); stem.position.set(0, 0.4, 0); this.ballBody.add(stem);
        
        this.ballFace = new THREE.Group();
        const eyeWhiteGeo = new THREE.SphereGeometry(0.12, 16, 16); const eyeWhiteMat = new THREE.MeshBasicMaterial({color:0xffffff});
        const eyeIrisGeo = new THREE.SphereGeometry(0.07, 16, 16); const eyeIrisMat = new THREE.MeshBasicMaterial({color:0x00aaff}); 
        const eyePupilGeo = new THREE.SphereGeometry(0.035, 16, 16); const eyePupilMat = new THREE.MeshBasicMaterial({color:0x000000});
        const eyeReflectGeo = new THREE.SphereGeometry(0.02, 8, 8);
        const createEye = (x) => {
            const g = new THREE.Group(); g.position.set(x, 0.08, 0.3);
            g.add(new THREE.Mesh(eyeWhiteGeo, eyeWhiteMat));
            const iris = new THREE.Mesh(eyeIrisGeo, eyeIrisMat); iris.position.z = 0.09; g.add(iris);
            const pupil = new THREE.Mesh(eyePupilGeo, eyePupilMat); pupil.position.z = 0.13; g.add(pupil);
            const reflect = new THREE.Mesh(eyeReflectGeo, eyeWhiteMat); reflect.position.set(0.03, 0.03, 0.15); g.add(reflect);
            return g;
        }
        this.ballFace.add(createEye(-0.14), createEye(0.14));
        this.mouthMesh = new THREE.Mesh(new THREE.TorusGeometry(0.06, 0.02, 8, 16, 3.14), new THREE.MeshBasicMaterial({color:'black'}));
        this.mouthMesh.position.set(0, -0.12, 0.36); this.mouthMesh.rotation.z = 3.14; this.ballFace.add(this.mouthMesh);
        this.ballBody.add(this.ballFace);

        const limbGeo = typeof THREE.CapsuleGeometry === 'function' ? new THREE.CapsuleGeometry(0.04, 0.15, 4, 8) : new THREE.CylinderGeometry(0.04, 0.04, 0.23, 8);
        const limbMat = new THREE.MeshBasicMaterial({color: 0xFF9966});
        const armL = new THREE.Mesh(limbGeo, limbMat); armL.position.set(-0.38, -0.1, 0); armL.rotation.z = 0.5; this.ballBody.add(armL);
        const armR = new THREE.Mesh(limbGeo, limbMat); armR.position.set(0.38, -0.1, 0); armR.rotation.z = -0.5; this.ballBody.add(armR);
        const legL = new THREE.Mesh(limbGeo, limbMat); legL.position.set(-0.15, -0.4, 0); this.ballBody.add(legL);
        const legR = new THREE.Mesh(limbGeo, limbMat); legR.position.set(0.15, -0.4, 0); this.ballBody.add(legR);
        this.scene.add(this.ballWrap);
    }

    setupLevel() {
        if(this.tower) this.scene.remove(this.tower);
        this.tower = new THREE.Group(); this.scene.add(this.tower);
        this.floors = []; this.interactables = []; this.physicsMeshes = []; 
        this.totalItems = 0; this.levelCollected = 0;
        this.collected = { apple: 0, banana: 0, diamond: 0, choco: 0, rotten: 0 };
        this.lastFloorY = -9999; 
        this.highestY = 0;      
        
        let grad = "";
        if(this.level === 1) grad = "linear-gradient(to bottom, #87CEEB, #E0F7FA)";
        else if(this.level === 2) grad = "linear-gradient(to bottom, #2c3e50, #000000)"; 
        else if(this.level === 3) grad = "linear-gradient(to bottom, #134E5E, #71B280)";
        else if(this.level === 4) grad = "linear-gradient(to bottom, #800000, #200122)";
        else grad = "linear-gradient(to bottom, #ECE9E6, #FFFFFF)";
        const overlayGradient = "linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0) 29%, rgba(0, 0, 0, 0.95) 100%)";
        const texture = `url("images/bg_level_${this.level}.jpg")`;
        document.body.style.backgroundImage = `${overlayGradient}, ${grad}, ${texture}`;
        document.body.style.backgroundRepeat = "no-repeat, no-repeat, repeat";
        document.body.style.backgroundSize = "cover, cover, 30%";
        document.body.style.backgroundBlendMode = "normal, multiply, normal";
        document.body.style.height = "100%";
        
        let fogCol = 0x000000;
        if(this.level === 1) fogCol = 0x88CCFF; else if(this.level === 5) fogCol = 0xFFF8E7;
        this.scene.fog.color.setHex(fogCol);
        
        let trackName = 'level_' + this.level;
        this.audio.playTrack(trackName);

        if(this.level === 6) this.maxTime = 120; else if(this.level === 4) this.maxTime = 90; else this.maxTime = 60;
        this.timeLeft = this.maxTime;

        const isBoss = this.level === 4; 
        const isFinal = this.level === 6; 
        
        const floors = isFinal ? 50 : (isBoss ? 20 : (this.level===1 ? 25 : 40));
        const matMap = (isBoss || isFinal) ? AssetFactory.texStone : AssetFactory.texFloor;
        const hidePole = (this.level === 6);
        
        let palette;
        if(this.level===1) palette=[0x00d2d3,0x54a0ff,0x5f27cd]; 
        else if(this.level===2) palette=[0xff9ff3,0xf368e0,0xff6b6b]; // Standard L2 colors
        else if(this.level===3) palette=[0xbadc58,0x6ab04c,0xf6e58d]; 
        else if(this.level===6) palette=[0xFFFFFF, 0xEEEEEE, 0xDDDDDD]; 
        else palette=[0x555555, 0x333333];
        
        // --- FIX: LAVA POLE FOR LEVEL 4 ---
        const poleMat = new THREE.MeshStandardMaterial({
            map: isBoss ? AssetFactory.texStone : AssetFactory.texPole,
            color: isBoss ? 0x888 : 0xddd,
            emissive: isBoss ? 0xff4500 : 0x000000,
            emissiveIntensity: isBoss ? 1.0 : 0
        });
        
        const core = new THREE.Mesh(new THREE.CylinderGeometry(1.5,1.5,200,32), poleMat);
        core.position.y = -80; if(hidePole) core.visible = false; this.tower.add(core);
        
        const alignedGapIndex = Math.floor(Math.random() * 12);
        
        for(let i=0; i<floors; i++) {
            const y = -i*4; const grp = new THREE.Group(); grp.position.y = y;
            let gap = Math.floor(Math.random()*12); if(i===0) gap=0;
            if(this.level === 3 && i >= 10 && i <= 18) gap = alignedGapIndex;
            let danger = (i>0 && i<floors-1 && Math.random()<0.1) ? Math.floor(Math.random()*12) : -1;
            if(isBoss || isFinal) danger = Math.floor(Math.random()*12);
            if(this.level === 3 && i >= 10 && i <= 18 && danger === gap) danger = -1;

            const col = palette[i % palette.length];
            const dangerColor = (isBoss || isFinal) ? 0xff4500 : 0xff4757;
            
            for(let j=0; j<12; j++) {
                if(j===gap || j===(gap+1)%12) continue;
                const isDanger = (j===danger);
                const shape = new THREE.Shape(); const a = Math.PI*2/12;
                shape.absarc(0,0, 1.6, j*a, (j+1)*a, false); shape.absarc(0,0, 2.5, (j+1)*a, j*a, true);
                const geo = new THREE.ExtrudeGeometry(shape, {depth:0.4, bevelEnabled:false}); 
                geo.rotateX(-Math.PI/2);
                const mat = new THREE.MeshBasicMaterial({ color: isDanger ? dangerColor : col, map: matMap, transparent: isFinal, opacity: isFinal ? 0.9 : 1.0 });
                const m = new THREE.Mesh(geo, mat); 
                m.userData = { type: isDanger?'danger':'safe', color: isDanger?dangerColor:new THREE.Color(col).getHex() };
                this.physicsMeshes.push(m); grp.add(m);
                if(!isDanger && !isBoss && i>0 && i<floors-1 && Math.random()<0.1) this.spawnItem(grp, Math.cos(j*a+a/2)*2, Math.sin(j*a+a/2)*2);
            }
            
            if(this.level === 6) { 
                if(i>2 && Math.random()<0.4) {
                    if(Math.random() > 0.5) this.spawnFlyingGhost(grp);
                    else this.spawnMonster(grp, false);
                } 
            }
            else if(isFinal) { 
                 if(i>2 && Math.random()<0.4) this.spawnFlyingGhost(grp); 
            }
            else { 
                const ghostChance = isBoss ? 0.6 : (this.level >= 2 ? 0.2 : 0); 
                if(i>0 && Math.random()<ghostChance) this.spawnMonster(grp, isBoss); 
            }

            if(this.level === 3 && i >= 10 && i <= 18) grp.rotation.y = 0; else grp.rotation.y = Math.random()*6;
            this.tower.add(grp); this.floors.push(grp);
        }
        
        const lastY = -floors*4; this.lastFloorY = lastY; 
        const fin = new THREE.Mesh(new THREE.CylinderGeometry(3,3,1,32), new THREE.MeshBasicMaterial({color:0x00ff00}));
        fin.position.y = lastY; fin.userData = {type:'finish'}; this.tower.add(fin); this.physicsMeshes.push(fin); 
        this.updateUI();
    }
    
    spawnItem(parent, x, z) {
        const r = Math.random(); let type = 'apple', tex = AssetFactory.textures['apple'];
        if(r>0.6) { type='banana'; tex=AssetFactory.textures['banana']; }
        if(r>0.75) { type='chocolate'; tex=AssetFactory.textures['choco']; } 
        if(r>0.88) { type='rotten'; tex=AssetFactory.textures['rotten']; }
        if(r>0.96) { type='diamond'; tex=AssetFactory.textures['diamond']; }
        
        const grp = new THREE.Group(); grp.position.set(x, 1.2, z);
        const mat = new THREE.SpriteMaterial({ map: tex || null, color: tex ? 0xffffff : 0xff0000 });
        const sprite = new THREE.Sprite(mat); sprite.scale.set(0.6, 0.6, 1);
        if(type==='banana') sprite.scale.set(0.7, 0.7, 1); if(type==='chocolate') sprite.scale.set(0.7, 0.7, 1);
        grp.add(sprite); grp.userData = { type: type }; parent.add(grp); this.interactables.push(grp);
        if(type !== 'rotten') this.totalItems++;
    }
    
    // --- FIX: MONSTER FACING ---
    spawnMonster(parent, isFire) {
        const col = isFire ? 0xff4500 : (this.level===3 ? 0x8A2BE2 : 0x32CD32); 
        const g = new THREE.Group();
        
        // VISUAL CONTAINER (to handle local rotation)
        const visual = new THREE.Group();
        g.add(visual);
        
        // ROTATE VISUALS 90deg on X axis so TOP (face) points FORWARD
        visual.rotation.x = -Math.PI / 2;

        const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), new THREE.MeshBasicMaterial({color:col}));
        visual.add(body);
        const eyeMat = new THREE.MeshBasicMaterial({color:'yellow'}); const pupilMat = new THREE.MeshBasicMaterial({color:'black'});
        const eyeL = new THREE.Mesh(new THREE.PlaneGeometry(0.15, 0.15), eyeMat); eyeL.position.set(-0.15, 0.1, 0.31);
        const pupilL = new THREE.Mesh(new THREE.PlaneGeometry(0.05, 0.05), pupilMat); pupilL.position.z = 0.01; eyeL.add(pupilL);
        const eyeR = new THREE.Mesh(new THREE.PlaneGeometry(0.15, 0.15), eyeMat); eyeR.position.set(0.15, 0.1, 0.31);
        const pupilR = new THREE.Mesh(new THREE.PlaneGeometry(0.05, 0.05), pupilMat); pupilR.position.z = 0.01; eyeR.add(pupilR);
        const browL = new THREE.Mesh(new THREE.PlaneGeometry(0.2, 0.05), new THREE.MeshBasicMaterial({color:'black'})); browL.position.set(-0.15, 0.22, 0.31); browL.rotation.z = -0.3;
        const browR = new THREE.Mesh(new THREE.PlaneGeometry(0.2, 0.05), new THREE.MeshBasicMaterial({color:'black'})); browR.position.set(0.15, 0.22, 0.31); browR.rotation.z = 0.3;
        const mouth = new THREE.Mesh(new THREE.PlaneGeometry(0.3, 0.1), new THREE.MeshBasicMaterial({color:'black'})); mouth.position.set(0, -0.15, 0.31);
        visual.add(eyeL, eyeR, browL, browR, mouth);
        
        // HANDS (Forward in local space after rotation)
        const armGeo = new THREE.BoxGeometry(0.15, 0.15, 0.4); 
        const armMat = new THREE.MeshBasicMaterial({color: 0x005500}); 
        const armL = new THREE.Mesh(armGeo, armMat); armL.position.set(-0.35, 0, 0.3); 
        const armR = new THREE.Mesh(armGeo, armMat); armR.position.set(0.35, 0, 0.3);
        visual.add(armL, armR);

        const legGeo = new THREE.BoxGeometry(0.15, 0.2, 0.15); const legMat = new THREE.MeshBasicMaterial({color: 0x006400}); 
        const legL = new THREE.Mesh(legGeo, legMat); legL.position.set(-0.15, -0.4, 0); const legR = new THREE.Mesh(legGeo, legMat); legR.position.set(0.15, -0.4, 0); 
        visual.add(legL, legR);
        
        const direction = Math.random() > 0.5 ? 1 : -1;
        g.userData = { type:'ghost', angle:Math.random()*6, speed:0.02, baseColor: col, dir: direction };
        g.position.y = 1.5; g.position.x = 2; g.rotation.set(0,0,0); parent.add(g); this.interactables.push(g);
    }
    
    spawnFlyingGhost(parent) {
        const g = new THREE.Group();
        const body = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.8}));
        const skirt = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 0.3, 16, 1, true), new THREE.MeshBasicMaterial({color:0xffffff, side:THREE.DoubleSide, transparent:true, opacity:0.8})); 
        skirt.position.y = -0.2; g.add(body, skirt);
        const eye = new THREE.Mesh(new THREE.SphereGeometry(0.08), new THREE.MeshBasicMaterial({color:0x000000})); eye.position.set(0.1, 0.05, 0.25);
        const eye2 = eye.clone(); eye2.position.set(-0.1, 0.05, 0.25); g.add(eye, eye2);
        
        const direction = Math.random() > 0.5 ? 1 : -1;
        g.userData = { type: 'white-ghost', angle: Math.random()*6, speed: 0.03, offset: Math.random()*3, baseColor: 0xffffff, dir: direction };
        g.position.set(Math.cos(0)*3, 2, Math.sin(0)*3); parent.add(g); this.interactables.push(g);
    }

    restart(full) {
        if(full) { 
            this.level = 1;
            this.score = 0; this.lives = 3; 
            this.collected = { apple: 0, banana: 0, diamond: 0, choco: 0, rotten: 0 };
            this.previousLevelsScore = 0; 
            this.currentLevelMaxDepth = 0;
            this.audio.playTrack('start_screen');
        }
        else {
            this.lives = Math.max(1, this.lives);
            if(this.floors) this.previousLevelsScore += 50; 
            this.currentLevelMaxDepth = 0;
        }
        
        this.ballWrap.position.y = 2; this.velocity = 0;
        this.fastTimer = 0; this.slowTimer = 0; this.invincible = 0; this.drillFloors = 0;
        this.lastTime = Date.now(); 
        
        this.ballMat.color.setHex(0xFF9966);
        if(this.mouthMesh) this.mouthMesh.rotation.z = 3.14; 
        
        document.getElementById('game-over-screen').classList.add('hidden');
        document.getElementById('level-complete-screen').classList.add('hidden');
        
        this.setupLevel();
        this.updateUI();
        this.isPlaying = true;
    }
    
    updateUI() {
        if(this.isPlaying) {
            const now = Date.now();
            const dt = (now - this.lastTime) / 1000;
            this.lastTime = now;
            if(dt < 1) { 
                this.timeLeft -= dt;
                if(this.timeLeft <= 0) { this.timeLeft = 0; this.handleTimeout(); }
            }
        }
        const m = Math.floor(this.timeLeft/60);
        const s = Math.floor(this.timeLeft%60).toString().padStart(2,'0');
        updateText('timer-display', `${m}:${s}`);
        updateText('score-board', this.score);
        
        let levelTxt = "LEVEL " + this.level;
        if(this.level === 4) levelTxt = "LAVA HELL";
        else if(this.level === 6) levelTxt = "THE END";
        updateText('level-indicator', levelTxt);

        let h = "";
        for(let i=0;i<Math.min(5,this.lives);i++) h+="‚ù§Ô∏è";
        updateText('hearts', h);
        
        let b = "";
        if(this.drillFloors > 0) b+="<span class='buff-drill'>üíéDRILL</span> ";
        else if(this.fastTimer>0) b+="<span class='buff-fast'>‚ö°FAST</span> ";
        else if(this.slowTimer>0) b+="<span class='buff-slow'>Ninja Turtle!</span>";
        updateHTML('buffs-display', b);
        
        updateText('c-apple', this.collected.apple);
        updateText('c-banana', this.collected.banana);
        updateText('c-choco', this.collected.choco);
    }
    
    handleTimeout() {
        this.takeDamage(true);
        if(this.lives > 0) {
            this.restart(false);
        }
    }

    loop() {
        try {
            requestAnimationFrame(() => this.loop());
            if(!this.isPlaying) return;
            
            this.particles.update();
            
            if(this.invincible > 0) { this.invincible--; if(this.invincible === 0) { this.ballMat.color.setHex(0xFF9966); if(this.mouthMesh) this.mouthMesh.rotation.z = 3.14; } }
            if(this.fastTimer>0) this.fastTimer--; if(this.slowTimer>0) this.slowTimer--;
            
            let grav = this.gravity; let jump = this.jumpForce;
            if(this.drillFloors > 0) { grav = 0.03; } else { if(this.fastTimer>0) { grav *= 2.0; jump *= 1.4; } if(this.slowTimer>0) { grav = 0.005; jump = 0.25; } }
            
            this.velocity -= grav; if(this.velocity < -0.8) this.velocity = -0.8; this.ballWrap.position.y += this.velocity;
            
            if(this.ballWrap.position.y > this.highestY) this.highestY = this.ballWrap.position.y;

            const speed = Math.abs(this.velocity);
            if(this.velocity < 0) this.targetScale.set(1 - speed*0.3, 1 + speed*0.5, 1 - speed*0.3); else this.targetScale.set(1, 1, 1);
            this.currentScale.lerp(this.targetScale, 0.2); this.ballBody.scale.copy(this.currentScale);
            
            this.ballBody.rotation.x -= 0.04; this.ballFace.rotation.copy(this.ballWrap.rotation); this.ballFace.rotation.z = Math.sin(Date.now()*0.01)*0.1;
            
            // --- FIX: PHYSICS RAYCAST (SKY RAY) ---
            if(this.velocity < 0) {
                // START RAYCAST FROM ABOVE THE BALL (y+1.5)
                const rayStart = this.ballWrap.position.clone();
                rayStart.y += 1.5; 
                this.raycaster.set(rayStart, new THREE.Vector3(0,-1,0));
                
                const hitsMain = this.raycaster.intersectObjects(this.physicsMeshes, false);
                const rayLen = Math.abs(this.velocity) + 3.0; 
                this.raycaster.far = rayLen;
                
                if(hitsMain.length > 0) {
                    const dist = hitsMain[0].distance;
                    if(dist < 1.9 + Math.abs(this.velocity) && dist > 0) { 
                         const u = hitsMain[0].object.userData.type ? hitsMain[0].object.userData : (hitsMain[0].object.parent ? hitsMain[0].object.parent.userData : {});
                         if(!['apple','banana','rotten','diamond','ghost','chocolate','white-ghost'].includes(u.type)) {
                            this.ballWrap.position.y = hitsMain[0].point.y + 0.4; 
                            if(u.type === 'safe') {
                                this.velocity = jump; this.audio.playSFX('bounce'); this.currentScale.set(1.4, 0.6, 1.4);
                                this.particles.spawn(this.ballWrap.position, u.color || 0xffffff);
                            } else if(u.type === 'danger' && this.drillFloors <= 0) {
                                this.takeDamage(); this.velocity = jump;
                            } else if(u.type === 'finish') { this.levelComplete(); }
                         }
                    }
                }
            }
            
            if(this.ballWrap.position.y < this.lastFloorY - 20) { 
                this.takeDamage(); 
                if(this.lives > 0 && this.floors.length > 0) { 
                    this.ballWrap.position.y = this.floors[0].position.y + 2; 
                    this.velocity = 0; 
                } 
            }
            
            // --- FIX: DRILL LOGIC DECREMENT ---
            const currentFloorIdx = Math.floor(Math.abs(this.ballWrap.position.y) / 4);
            if(this.drillFloors > 0) { 
                if(currentFloorIdx > (this.lastFloorIdx||0)) { 
                    this.drillFloors--; 
                    this.audio.playSFX('damage'); 
                    this.particles.spawn(this.ballWrap.position, 0x00ffff); 
                } 
            }
            this.lastFloorIdx = currentFloorIdx;
            
            // --- INTERACTIONS ---
            const pos = this.ballWrap.position;
            for(let i=this.interactables.length-1; i>=0; i--) {
                const o = this.interactables[i];
                if(!o || !o.parent) { this.interactables.splice(i, 1); continue; }
                
                if (o.userData.type === 'ghost') {
                    if (!o.userData.isStatic) {
                        let dir = o.userData.dir || 1; 
                        o.userData.angle += o.userData.speed * dir; 
                        const r = 2; 
                        o.position.x = Math.cos(o.userData.angle) * r; 
                        o.position.z = Math.sin(o.userData.angle) * r; 
                        
                        // Look at Tangent
                        const nextAngle = o.userData.angle + (0.1 * dir); 
                        const tx = Math.cos(nextAngle) * r;
                        const tz = Math.sin(nextAngle) * r;
                        o.lookAt(tx, o.position.y, tz);
                    } 
                }
                else if(o.userData.type === 'white-ghost') { 
                    let dir = o.userData.dir || 1;
                    o.userData.angle += o.userData.speed * dir; 
                    const rad = 2.5 + Math.sin(Date.now() * 0.002 + o.userData.offset) * 1.5; 
                    o.position.x = Math.cos(o.userData.angle) * rad; 
                    o.position.z = Math.sin(o.userData.angle) * rad; 
                    o.position.y = 2 + Math.sin(Date.now() * 0.002 + o.userData.offset) * 2; 
                    o.lookAt(pos); 
                }
                
                const wPos = new THREE.Vector3(); o.getWorldPosition(wPos);
                const dist = o.userData.type === 'white-ghost' ? 1.0 : 0.8;
                
                if(wPos.distanceTo(pos) < dist) {
                    const t = o.userData.type;
                    if(t==='apple') { this.lives=Math.min(5,this.lives+1); this.collected.apple++; this.levelCollected++; this.audio.playSFX('collect'); o.parent.remove(o); this.interactables.splice(i,1); }
                    else if(t==='banana') { this.fastTimer+=300; this.collected.banana++; this.levelCollected++; this.audio.playSFX('buff'); o.parent.remove(o); this.interactables.splice(i,1); }
                    else if(t==='rotten') { this.slowTimer+=300; this.audio.playSFX('damage'); this.collected.rotten++; o.parent.remove(o); this.interactables.splice(i,1); }
                    else if(t==='diamond') { this.drillFloors = 3; this.audio.playSFX('buff'); this.collected.diamond++; o.parent.remove(o); this.interactables.splice(i,1); }
                    else if(t==='chocolate') { this.timeLeft += 5; this.collected.choco++; this.audio.playSFX('collect'); o.parent.remove(o); this.interactables.splice(i,1); }
                    else if(t==='ghost' || t==='white-ghost') { if(this.drillFloors<=0) this.takeDamage(); else { o.parent.remove(o); this.interactables.splice(i,1); } }
                }
            }
            
            const currentDepth = Math.floor(Math.abs((pos.y - 2) / 4));
            if(currentDepth > this.currentLevelMaxDepth) { this.currentLevelMaxDepth = currentDepth; }
            this.score = this.previousLevelsScore + this.currentLevelMaxDepth;
            this.updateUI();

            const ty = pos.y + 8; 
            this.camera.position.y += (ty - this.camera.position.y) * 0.1;
            this.camera.lookAt(0, this.camera.position.y - 8, 0);

            this.renderer.render(this.scene, this.camera);
        } catch(e) { console.error("Loop Error:", e); }
    }

    takeDamage(isTimeout = false) {
        if(this.invincible>0 || this.drillFloors>0) return;
        this.lives--;
        this.particles.spawn(this.ballWrap.position, 0xff0000);
        this.ballMat.color.setHex(0xFF4444); if(this.mouthMesh) this.mouthMesh.rotation.z = 0; 
        if(this.lives<=0) {
            this.isPlaying=false; this.audio.stopMusic(); this.audio.playSFX('damage'); this.audio.playTrack('game_over');
            document.getElementById('game-over-screen').classList.remove('hidden');
            updateText('fail-reason', isTimeout ? "TIME UP!" : "SMASHED!"); updateText('go-score', this.score);
            if(this.score > this.bestScore) this.bestScore = this.score; updateText('go-best', this.bestScore);
        } else {
            this.audio.playSFX('damage'); if(!isTimeout) { this.velocity = this.jumpForce; this.invincible = 60; }
        }
    }
    
    levelComplete() {
        this.isPlaying = false;
        if(this.level === 6) { updateText('complete-title', "YOU WIN!"); updateText('win-emoji', "üèÜ"); updateText('btn-next', "RESTART GAME"); this.audio.playTrack('you_win'); } 
        else { updateText('complete-title', "LEVEL COMPLETE!"); updateText('btn-next', "NEXT LEVEL"); this.audio.playTrack('you_win'); }
        document.getElementById('level-complete-screen').classList.remove('hidden');
        const timeTaken = Math.max(0, this.maxTime - this.timeLeft);
        const m = Math.floor(timeTaken/60); const s = Math.floor(timeTaken%60).toString().padStart(2,'0'); updateText('win-time', `${m}:${s}`);
        const total = this.totalItems||1; const fruitPct = Math.min(100, Math.floor(this.levelCollected/total*100)); updateText('win-fruit', this.levelCollected+"/"+this.totalItems);
        let rating = "Good"; let ratingVal = 50; if(fruitPct > 80 && timeTaken < this.maxTime*0.5) { rating="Perfect!"; ratingVal=100; } else if(fruitPct > 50) { rating="Great"; ratingVal=75; }
        updateText('win-rating', rating); if(this.level !== 6) updateText('win-emoji', ratingVal===100?"üëë":"üéâ");
        setTimeout(() => { updateBar('bar-time', ((this.maxTime - timeTaken) / this.maxTime) * 100); updateBar('bar-fruit', fruitPct); updateBar('bar-rating', ratingVal); }, 100);
    }
}

window.addEventListener('DOMContentLoaded', () => {
    try { AssetFactory.init(); window.game = new Game(); const startBtn = document.getElementById('btn-start'); if(startBtn) { startBtn.onclick = function() { window.game.start(); }; } } catch(e) { console.error("Initialization failed:", e); }
});
</script>
</body>
</html>
